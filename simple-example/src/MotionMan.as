package{	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Matrix3D;	import flash.geom.Point;	import flash.geom.Vector3D;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.*;		import com.perfume.utils.bvh.*;	public class MotionMan{		internal var bvh:Bvh;		private var circles:Array;		private var target:Sprite;		public function MotionMan(_target:Sprite, _path:String){			target = _target;			load(_path);		}				public function destroy():void{			if ( bvh ) bvh.destroy();			bvh = null;			for each ( var sp:Sprite in circles ) if ( sp.parent ) sp.parent.removeChild(sp);			circles = null;			target = null;		}				protected function load(_path:String, _fn:Function = null):void{// load bvh and parse			var ld:URLLoader = new URLLoader();			ld.addEventListener(Event.COMPLETE, function(e:Event):void{				ld.removeEventListener(Event.COMPLETE, arguments.callee);				bvh = new Bvh(String(ld.data));				bvh.isLoop = true;				createCircles(bvh.bones.length + 5);				if ( _fn != null ) _fn();			});			ld.load(new URLRequest(_path));		}				protected function createCircles(_num:int):void{			circles = [];			var sp:Sprite;			var col:uint = Math.random()*0xFFFFFF;			for ( var i:int=0; i<_num; i++ ){				sp = new Sprite();				sp.graphics.beginFill(col,1);				sp.graphics.drawCircle(0,0,4);				target.addChild( sp );					circles.push( sp );			}		}				private function calcBonePosition(bone:BvhBone, matrix:Matrix3D):void{			// coordinate system in BVH is right-handed.			while ( bone ) {				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendRotation(-bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(-bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendTranslation(bone.Xposition+bone.offsetX, bone.Yposition+bone.offsetY, -(bone.Zposition+bone.offsetZ));				bone = bone.parent;			}			// if BVH's coordinate system is left-handed then use below.			/*			while ( bone ) {				matrix.appendRotation(bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendRotation(bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendTranslation(bone.Xposition+bone.offsetX, bone.Yposition+bone.offsetY, bone.Zposition+bone.offsetZ);				bone = bone.parent;			}			*/		}		public function update(_time:Number):void{			if ( !bvh ) return;			//frame of BVH			bvh.gotoFrame( _time/(bvh.frameTime*1000) );						//calculate joint's position			var a:Array = [];			for each (var bone:BvhBone in bvh.bones) {				var _p0:BvhBone = bone;				var matrix:Matrix3D = new Matrix3D();				calcBonePosition(bone, matrix);				a.push(_p0, matrix.position.x, matrix.position.y - 70, -matrix.position.z);								if ( _p0.isEnd ) {// endSite					bone = _p0;					matrix.identity();					matrix.appendTranslation(bone.endOffsetX, bone.endOffsetY, -bone.endOffsetZ);					calcBonePosition(bone, matrix);					a.push(_p0, matrix.position.x, matrix.position.y - 70, -matrix.position.z);				}			}						// re-position			var i:int = 0;			var l:int = a.length/4;			var sp:Sprite;			for ( i = 0; i<l; i++ ) {				sp = circles[i];
				sp.x = a[i*4+1] * 2;				sp.y = -a[i*4+2] * 2;				sp.z = a[i*4+3] * 2 + 200;			}			drawLines(target, a);		}				private function drawLines(_target:Sprite, a:Array):void{			var i:int = 0;			var l:int = a.length;			var sp:Sprite;			var sp2:Sprite;			var pt:Point;			var pt2:Point;			var _b:BvhBone;			var _b2:BvhBone;			var _index:int;			const ZERO:Point = new Point();			for ( i=0; i<l; i+=4 ){				_b = a[i];				sp = circles[i / 4];				pt = sp.localToGlobal(ZERO);				if ( _b.children.length > 0 ){					for each ( _b2 in _b.children ) {						_index = a.indexOf(_b2);						sp2 = circles[_index / 4];						pt2 = sp2.localToGlobal(ZERO);						_target.graphics.lineStyle(1, 0x777777);						_target.graphics.moveTo(pt.x - _target.x, pt.y - _target.y);						_target.graphics.lineTo(pt2.x - _target.x, pt2.y - _target.y);					}				} else if ( _b.isEnd ) {					_b2 = a[i+4];					if ( _b == _b2 ) {						_index = i+4;						sp2 = circles[_index / 4];						pt2 = sp2.localToGlobal(ZERO);						_target.graphics.lineStyle(1, 0x00AAFF);						_target.graphics.moveTo(pt.x - _target.x, pt.y - _target.y);						_target.graphics.lineTo(pt2.x - _target.x, pt2.y - _target.y);					}				}			}		}	}}